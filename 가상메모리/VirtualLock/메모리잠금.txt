가상 주소 공간은 논리적으로 존재할 뿐이며 실제로 데이터나 코드가 저장되는 곳은 가상 메모리이다.
여기서 가상 메모리라고 칭하는 것은 RAM과 하드 디스크의 페이징 파일을 합쳐 부르는 말이다.
페이징 파일도 RAM보다 좀 느릴 뿐이지 분명히 메모리이다.


운영체제는 RAM과 페이징 파일 사이를 끊임없이 교체하면서 돌아간다.

당장 필요한 부분은 RAM으로 읽혀지며 당분간 사용되지 않은 부분은 페이징 파일로 이동된다.

운영체제의 이런 가상 메모리 관리는 응용 프로그램 입장에서 볼 때 완전히 투명하다.
즉, 원하는 데이터가 RAM에 있든 페이징 파일에 있는 전혀 구분할 필요가 없다는 뜻이다.

다만 속도가 조금 차이나며 가상 메모리의 통제가 완전히 운영체제의 고유하고 독점적인 권한이라는 것만 알아두자.
프로그램은 이에대해 별로 간섭할 필요가 없다.

그러나

아주 특별한 경우, 주로 속도가 지극히 중요한 프로그램의 경우 특정 데이터가 반드시 RAM에만 있도록 할 수 있다.

즉, 페이징 파일로 복사하지 못하게 금지할 수 있는데 이렇게 하면 원하는 데이터를 물리 RAM에서 바로 찾을 수 있으므로 속도가 더 빨라진다.

이 때는 다음 두 함수를 사용한다.

> BOOL VirtualLock(LPVOID lpAddress, DWORD dwSize);
> BOOL VirtualUnLock(LPVOID lpAddress, DWORD dwSize);



VirtualLock 함수는 lpAddress가 지정한 번지로부터 dwSize 길이만큼의 메모리 페이지를 잠근다.
이렇게 되면 운영체제는 이 번지의 데이터는 페이징 파일로 보내지 않고 항상 RAM에 남아있도록 하여 최대한 신속하게 상ㅇ할 수 있도록 보장한다.



이때 lpAddress번지는 반드시 가상 메모리가 맵되어 있는 확정 상태여야만 한다.



그렇지 않으면 잠금 동작 자체가 무의미 하다.
잠금을 풀때는 VirtualUnlock 함수를 사용한다.

잠겨진 메모리에 대해서는 페이징 파일로 스왑하지 않아 원하는 데이터가 RAM에 없는 상태(Page Fault)가 발생하지 않는다.

단 예외적으로 해당 프로세스가 액티브 상태가 아니면 이 때는 잠김 페이지라도 페이징 파일로 이동시켜버릴 수 있다.

메모리를 잠그면 응용 프로그램은 자신이 필요로 하는 데이터를 언제나 RAM에서 읽으므로 더 빨리 실행될 수 있어서 좋겠지만 이 기능은 반드시 꼭 필요한 부분에만 신중하게 사용해야 한다.

그렇지 않고 남발하게 되면 운영체제의 시스템 관리 능력을 저해하여 자칫하면 전반적으로 속도가 느려질 수 있다.

Win32의 메모리 관리 알고리즘은 상당히 정교하며 효율적으로 작성되어 있으므로 굳이 메모리를 잠그지 않아도 큰 불편 없이 쓸 수 있다.




메모리 잠금을 반드시 사용해야 하는 프로그램은 디바이스 드라이버 정도이다.




응용 프로그램 수준에서는 거의 쓸 일이 없으며 함부로 메모리 관리에 개입해서는 안된다.
멀티 태스킹은 운영체제의 지휘 아래 응용 프로그램들의 자발적인 협조에 의해 부드럽게 돌아가는 것인데 특별한 이유없이 혼자서 자원과 시간을 독점하는 것은 금물이다.