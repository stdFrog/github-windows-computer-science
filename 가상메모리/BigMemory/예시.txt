BigMemory 예제는 실습에서 자주 발생하는 문제를 다룬다.


네트워크 또는 DB에서 레코드를 메모리로 읽어들이는 상황을 가정하며, 각기 다른 크기의 레코드들을 실제로 어떻게 읽어오는지에 대해 아주 상세하게 기록했다.

즉, 미래의 일을 예측할 수 없는 상황에서 어떻게 메모리를 할당하고 회수해야 하는지에 대해 이해하기 쉽게 작성해뒀다.





BigMemory와 BigMemory2의 차이는 확연히 느낄 수 있다.

VirtualAlloc을 사용해 미리 충분한 공간을 예약해두는 BigMemory 예제는 할당하고 해제하는 동작이 굉장히 빠르게 진행되나 realloc으로 재할당하는 BigMemory2 예제는 그 속도가 눈에 띄게 느리다.

realloc을 사용하면 미리 공간을 확보해두는 것이 아니라 그때그때 재할당하는 것이기 때문에 읽고 쓰는 동작이 매번 발생하고 그로 인해 전체적으로 속도가 느리다는 차이점이 있다.


또한, VirtualAlloc과 달리 realloc에 의해 재할당될 때마다 번지가 바뀔 수 있다는 단점도 있다.


realloc에 의해 베이스가 바뀔 수 있으므로 포인터는 사용할 수 없으며 이 역시 속도 저하의 이유중 하나가 된다.

속도를 좀 높이려면 재할당할 때 여유분을 충분히 주는 방법을 사용할 수는 있지만 그럴거라면 차라리 가상 메모리를 쓰는 것이 더 나으며, 이 방법 역시 가상 메모리를 쓰는 것보다는 확실히 성능이 떨어진다.


대용량의 가변적인 메모리를 다룰 때는 가상 메모리의 이점을 활용하는 것이 더 좋다.


가상 메모리는 예약 후 필요한만큼만 점진적으로 확정해 가며 쓸 수 있으므로 물리적인 메모리를 낭비하지 않으면서도 한번 예약한 번지가 바뀌지도 않아 쓰기 편리하고 속도도 빠르다.

단, 가상 메모리는 할당 단위가 크므로 필요 메모리량이 클 때만 사용하는 것이 좋다.

연결 리스트의 노드처럼 작은 메모리를 할당할 때는 realloc을 쓰는 것이 더 바람직하다.