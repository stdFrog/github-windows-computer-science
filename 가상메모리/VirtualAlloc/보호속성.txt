VirtualAlloc의 네 번째 인수 flProtect는 할당하고자 하는 메모리의 액세스 타입(Access Protection)을 지정한다.

Win32 가상 메모리의 특징 중 하나가 메모리 페이지마다 액세스 타입을 설정하여 미연의 실수를 방지할 수 있다는 점이다.

마치 파일에 읽기 전용 속성을 주어 실수로 지워지지 않도록 하는 것과 개념적으로 동일하다.

지정 가능한 플래그는 다음과 같으며 이 중 PAGE_GUARD, PAGE_NOCACHE 플래그는 PAGE_NOACCESS 플래그를 제외한 다른 플래그와 함께 사용될 수 있다.


___________________________________________________________________________________________________
액세스 권한		설명
===============================================================
PAGE_READONLY		읽기만 가능하다. 이 메모리에는 쓰기를 할 수 없다.
PAGE_READWRITE		읽기 쓰기가 가능하다.
PAGE_EXECUTE		실행만 가능하다. 읽기, 쓰기 모두 할 수 없다.
PAGE_EXECUTE_READ	실행 및 읽기만 가능하다
PAGE_EXECUTE_READWRITE	실행, 읽기, 쓰기가 가능하다.

PAGE_GUARD		보호 페이지로 지정한다. 이 페이지에서 읽기, 쓰기를 시도하면
			STATUS_GUARD_PAGE 예외가 발생하며 보호 페이지 상태가
			해제된다. 보호페이지는 메모리의 끝을 표시하는 용도로
			자주 사용된다.

PAGE_NOACCESS		어떤 액세스도 하지 못하게 한다. 읽기,쓰기,실행 다 못한다.

PAGE_NOCACHE		캐시를 금지한다. 일반적으로 응용 프로그램은
			이 플래그를 사용하지 않는 것이 좋다.
			디바이스 드라이버 등의 시스템 소프트웨어에서
			이 플래그를 사용한다.

PAGE_EXECUTE_WRITECOPY	공유된 영역에 쓰기를 할 때 사본을 작성한다. (NT 이상만 지원)
===============================================================



일반적인 용도로 읽기도 하고 쓰기도 할 메모리라면 PAGE_READWRITE로 지정하여 마음대로 읽고 쓰도록 하면 된다.

그러나 특정 목적으로 읽기만 하고 쓰지는 못하게 하려면 PAGE_READONLY 플래그를 지정한다.
이렇게 할당된 메모리는 읽을 수는 있어도 쓸 수는 없다.

만약 읽기 전용의 메모리에 쓰기를 시도하면 Access Violation 예외가 발생한다.




여기서 읽기 및 쓰기는 다 이해하겠는데 실행 전용이라는 말은 선뜻 이해가 되지 않을 것이다.

읽기는 해당 메모리의 데이터를 읽을 수 있다는 말이며 실행은 해당 메모리의 코드를 CPU가 실행할 수 있다는 뜻이다.

현재까지의 모든 시스템(인텔, 알파)은 읽을 수 있으면 실행도 가능하므로 사실 아직까지 읽기 전용과 실행 전용은 같은 뜻이다.

Win32가 플랫폼에 독립적인 API이다 보니 미래에 읽기와 실행을 구분하는 CPU를 위해 이런 액세스 타입을 미리 준비해 두고 있을 뿐이다.



메모리의 액세스 타입은 할당할 때 지정하지만 실행중에도 다음 함수를 사용하여 변경할 수 있다.

> BOOL VirtualProtect(LPVOID lpAddress, DWORD dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);




하지만 응용 프로그램 수준에서 메모리의 액세스 타입을 그것도 실행중에 변경하는 경우는 지극히 드물며 예를 들기도 무척 곤란하다.

꼭 예를 들자면 아주 중요한 데이터를 특정 함수만 변경하고 싶을 때 읽기 전용으로 만들어 두고 이 함수에서만 액세스 타입을 잠시 바꾸는 정도가 있다.

시스템의 함수를 훅킹하는 고난이도의 기법을 구사할 때 이 함수를 쓴다.


가상 메모리의 보호 속성은 프로그램 로더가 사용한다.

응용 프로그램을 메모리로 읽어올 때 실행 파일(PE)에 기록되어 있는 섹션 속성에 따라 쓰기가 가능한 메모리 영역과 읽을 수만 있는 메모리 영역이 구분되어 가상 메모리에 배치된다.

일반적으로 코드 영역은 읽기 전용이며 전역 변수 영역은 읽고 쓸 수 있는 영역이다.

하지만 문자열 상수는 읽기 전용 영역에 배치되므로 이 값은 실행중에 변경할 수 없다.



AccViolation 예제를 본 후 아래를 읽어보자.





정수형 변수 i는 언제든지 변경할 수 있지만 str이 가리키고 있는 문자열 상수 영역은 읽을 수만 있으므로 이 포인터가 가리키는 번지를 변경할 수는 없다.

마우스 오른쪽 버튼을 누르면 이 프로그램은 Access Violation 예외를 발생시키며 종료된다.
16비트의 메모리는 이런 구분이 없기 때문에 우발적인 사고로 코드 영역을 건드릴 수도 있었는데 32비트의 가상 메모리는 메모리에 속성을 부여함으로써 변경되지 말아야 할 영역을 보호할 수 있다.



PAGE_GUARD 속성은 가드 페이지를 설정함으로써 효율적인 스택 확장에 사용된다.
스택은 기본적으로 1M 예약되며 그 중 한 페이지 분량인 4K 정도만 확정된 채로 생성된다.



예약된 1M는 스택의 최대 크기이며 확정된 페이지는 당장 사용할 수 있는 영역인데 스택을 많이 사용하면 확정을 점점 늘린다.

이때 스택을 언제 확장할지를 결정하기 위해 운영체제가 사용하는 속성이 PAGE_GUARD이다.

스택이 확장되는 과정은 다음과 같은데 아래쪽이 높은 번지이며 격자 하나가 1페이지이다.

===============================================================
예약	예약	예약
예약	예약	예약
예약	예약	가드
예약  >	가드  >	확정
가드	확정	확정
확정	확정	확정
===============================================================


최초 제일 높은 번지의 한 페이지만 확정되어 있으며 이 안에서 함수를 호출하고 지역변수를 생성한다.

그러다가 스택 사용량이 늘어 가드 페이지에 닿으면 예외가 발생하는데 운영체제는 이 예외가 발생했을 때 가드 페이지를 추가로 확정하고 바로 다음의 예약 페이지를 다시 가드 페이지로 설정한다.

만약 가드 페이지가 없다면 스택을 액세스할 때마다 확정 여부를 점검해야 하므로 무척 비효율적일 것이다.



이런식으로 스택은 점진적 확장을 거치는데 유일하게 마지막 페이지는 확정하지 않음으로써 예약된 1M 영역을 절대로 넘지 않게끔 한다.


만약 스택 크기가 1M를 넘어 오버플로우가 발생했다면 이는 대개의 경우 프로그램의 논리가 잘못된 것이다.


스택은 함수를 호출함에 따라 오르락 내리락거리는 것인데 이 정도로 커졌다면 재귀 호출이 잘못된 경우이므로 예외를 일으키고 죽도록 내버려 두는 편이 더 낫다.



참고로 95/98에서는 PAGE_GUARD 속성이 지원되지 않아서 PAGE_NOACCESS 속성이 대신 사용된다.