앞에서 Win32의 메모리 구조는 프로세스끼리 분리되어 메세지를 통해 포인터를 전달하는 간단한 방법으로는 문자열을 공유할 수 없다고 했다.


그런데 이번 예제는 다르다.

7장에서 실습해본 My ListBox라는 이름의 예제를 실행하고 이번 SetOtherText 예제를 실행하면
서로 다른 프로세스임에도 문자열이 전달된다.


즉, 문자열이 프로세스의 경계를 넘나들고 있는 것이다.


이 코드가 잘 동작하는 이유가 뭘까?


시스템이 내부적으로 메모리 맵 파일을 생성하여 보내는 쪽의 문자열을 공유 영역에 복사하고
받는 쪽에서 이 영역을 읽을 수 있도록 조치하기 때문이다.

결국 ListBox 예제의 메인 윈도우와 리스트 박스 컨트롤은 시스템이 만든 메모리 맵 파일을 통해 문자열을 전달받는 것이다.



이 임시적인 메모리 맵 파일은 프로세스간의 통신을 위해 생성되며 SendMessage가 리턴될 때 파괴된다.

시스템이 중간에서 통신을 위한 장치를 만들고 파괴해야 하므로 상당한 시간과 자원이 소모될 것이다.



 그다음, ListCtrl 예제를 실행하고 리스트 뷰 컨트롤에 새로운 항목을 추가해보자.




우측 버튼을 클릭하여 메세지를 사용하는데 LVM_INSERTITEM 메시지를 리스트 뷰 컨트롤로 보낸다.

그러나 실행해 보면 이 코드는 제대로 동작하지 않으며 때로는 위험한 결과(다운)가 초래될 수도 있다.

리스트 뷰 컨트롤이 SetOtherText 프로세스의 주소 공간에 있는 LVITEM 구조체를 읽지 못하기 때문이다.




운영체제는 필요하다고 판단될 경우 임시적인 메모리 맵 파일을 생성하여 프로세스간의 자료 교환을 돕지만 그렇지 않을 경우는 아무 조치도 취하지 않는다.



그렇다면 왜 WM_SETTEXT나 LB_ADDSTRING에 대해서는 비싼 비용을 치르고도 이런 처리를 할까?


그 이유는 바로 호환성 때문이다.





오버랩드 윈도우나 리스트 박스같은 표준 컨트롤은 16비트 윈도우 시절부터 존재했었고 16비트의 메모리는 분리되어 있지 않았다.

그래서 메시지를 통한 포인터 교환이 가능했었고 또한 유용한 기법의 하나로 널리 활용되었다.

이런 기법을 활용한 16비트 프로그램이 32비트에서도 여전히 실행 가능해야 하는데 32비트의 분리된 메모리 구조에서는 사실상 포인터를 통한 자료 교환이 불가능하다.

그래서 운영체제는 호환성 확보를 위해 무슨 수를 쓰든지 이 코드가 동작하도록 보장해야 했으며 그 방편으로 메모리 맵 파일을 활용하는 것이다.

물론 외부에서 볼 때는 이런 처리가 투명해서 전혀 눈치채지 못한다.

반면 공통 컨트롤은 32비트 윈도우즈에서 처음 만들어졌고 메시지를 통한 프로세스간의 자료 교환이 처음부터 불가능했다.

그러므로 이 컨트롤에 대해서는 시스템이 지나친 서비스를 할 필요가 없으며 동작하지 않는다 하여 문제가 되지도 않는 것이다.

그래서 표준 컨트롤은 16비트 방식대로 프로그래밍 해도 동작하지만 다른 프로세스의 공통 컨트롤을 프로그래밍하려면 훅킹이라는 어려운 기법이 동원되어야 한다.