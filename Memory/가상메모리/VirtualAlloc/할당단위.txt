VirtualAlloc 함수가 메모리를 할당할 때는 바이트 단위를 사용하지 않는다.

4G나 되는 주소 공간을 바이트 단위로 사용하는 것은 너무 비효율적이기 때문에 일정한 단위로 주소 공간을 분할한다.

마치 하드 디스크가 바이트 단위로 파일을 기록하지 않고 섹터, 클러스터 단위를 사용하는 것처럼 말이다.

클러스터 단위로 파일을 기록하면 낭비되는 디스크 공간이 생기지만 속도는 훨씬 더 빨라진다.



가상 주소 공간의 단위는 두 가지가 있다.

우선, 할당의 시작점을 지정하는 할당 단위(Allocation Granualrity)가 있고 할당의 크기를 지정하는 페이지(Page)가 있다.

이런 단위를 사용하여 메모리를 관리하는 이유는 메모리가 지나치게 조각나는 것을 방지하고 좀 더 신속하게 메모리를 관리하기 위해서이다.



VirtualAlloc으로 메모리를 할당(예약 또는 확정)할 때 그 시작점은 반드시 할당 단위의 경계선에 정려뢴다.
즉, 할당 단위의 배수 위치에서 할당이 시작된다.

대부분의 플랫폼에서 할당 단위는 64K이므로 가상 메모리 공간은 64K 단위로 할당된다고 할 수 있다.

예를 들어 다음과 같이 예약 명령을 내렸다고 하자.

> ptr = (int*)VirtualAlloc(0xb71234, sizeof(int)*10, MEM_RESERVE, PAGE_READWRITE);





예약의 시작점을 0xb71234번지로 강제로 지정하였다.
그러나 운영체제는 정확하게 이 번지에서 할당을 시작하지 않고 할당 단위의 배수가 되도록 번지를 내림하여 할당한다.

이 경우 실제 예약되는 번지는 0xb70000번지가 된다.


하위 2바이트를 0으로 만든 번지에서 할당된다고 생각하면 된다.





또한, 할당된 영역의 크기는 반드시 페이지 단위의 배수가 된다.

페이지의 크기는 플랫폼에 따라 다른데 인텔을 비롯한 대부분의 시스템에서 페이지 크기는 4K바이트이다.


예를 들어 10K의 크기만큼 할당을 요청했다면 실제로 할당되는 영역의 크기는 12K가 될 것이다.


현재 플랫폼에서 할당 단위와 페이지 크기를 조사하고 싶으면 GetSystemInfo 함수를 사용하면 된다.


> GetSysInfo 예제를 보자.