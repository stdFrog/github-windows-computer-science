디폴트 힙의 용량이 충분하며 부족할 경우 자동으로 늘리므로 디폴트 힙만 사용해도 웬만한 메모리 요구는 다 충족할 수 있다.

그런데 특별한 이유로 디폴트 힙이 아닌 별도의 힙을 만들고자 한다면 그렇게 할 수도 있다.
어떤 경우에 힙을 만들어 사용하는 것이 좋은지 보자.


1. 동적으로 필요한 메모리가 두 종류가 있으며 두 메모리가 질적으로 다를 경우 각각의 고유 힙을 만들 수 있다.
예를 들어 두 개의 연결 리스트를 관리할 경우 각 연결 리스트별로 별도의 힙을 만들어 메모리를 할당하면 각 리스트끼리의 노드가 분리 할당됨으로써 잠재적인 문제를 방지할 수 있다.
한쪽 연결 리스트의 버그로 인해 다른 연결 리스트까지 같이 파괴되지 않을 것이다.
또한, 두 리스트의 노드 크기가 다를 때 빈번하게 할당/해제되더라도 메모리의 단편화 현상(fragmentation)을 최소화할 수 있다. 왜냐하면 노드가 해제된 자리에 같은 크기의 노드를 할당하면 낭비가 전혀 없기 때문이다.


2. 스레드별로 사용하는 힙을 따로 만들 경우 동기화를 하지 않아도 상관없다.
특정 스레드가 자신이 사용할 힙을 만들어서 사용하면 이 힙은 혼자서 사용하므로 다른 스레드의 방해를 받지 않고 안전하게 사용할 수 있다.
이런 경우 힙 생성 함수에 HEAP_NO_SERIALIZE 플래그를 지정하여 동기화를 하지 않도록 하고 속도를 더 높여도 무관하다.


3. 힙에 할당된 개별 블록을 한꺼번에 해제할 수 있다.
힙이 파괴되면 그 안의 블록들도 자동으로 파괴되므로 파괴 속도가 굉장히 빠르다.
이 특징은 상당히 유용한데 거대한 이진 트리가 있을 때 트리의 노드들이 할당한 메모리를 해제하기 위해서는 또 한번의 순회가 필요하지만 별도의 전용 힙에 트리를 구성해 놓았으면 힙만 파괴함으로써 모든 노드를 한꺼번에 해제할 수 있다.




이 외에도 논리적으로 용도가 비슷한 메모리를 각각 분리된 힙에 할당함으로써 운영체제가 페이지를 좀 덜 교체할 수 있도록 하여 속도를 높일 수 있다.

힙을 더 만들 수 있다는 것은 논리적으로 메모리의 구획을 나눔으로써 안전성과 편의성을 높이는 훌륭한 기능이다.

===============================================================


힙 생성 함수

> HANDLE HeapCreate(DWORD flOptions, DWORD dwInitialize, DWORD dwMaximumSize);
> BOOL HeapDestroy(HANDLE hHeap);


첫 번쨰 인수 flOptions는 새로 생성되는 힙의 속성을 설정하는 플래그를 지정하며 동기화 금지, 예외 발생 등의 플래그를 지정할 수 있다.
하지만, 통상 0으로 지정한다.

두 번째 인수로 초기에 확정될 힙의 크기를 지정하며 세 번째 인수로 힙의 최대 크기를 지정한다.

운영체제는 HeapCreate가 지정한 dwMaximumSize 만큼의 주소 공간을 예약하고 그 중 dwInitializeSize 만큼 확정한다.
그리고 힙으로부터 메모리가 점점 할당됨에 따라 예약분을 필요한만큼 확정해 나간다.



dwMaximumSize가 0이면 상한이 없다는 뜻이며 이 경우 힙은 가상 메모리 크기만큼 커질 수 있다.

힙은 스택과는 달리 필요한만큼 얼마든지 할당해서 쓸 수 있어야 하므로 상한을 두지 않는 것이 보통이다.



HeapCreate는 생성된 힙의 핸들을 리턴하며 에러 발생시 NULL을 리턴한다.
이 핸들은 HeapAlloc 등의 함수의 첫 번째 인수로 쓰인다.



사용자가 생성한 힙은 디폴트 힙과 달리 HeapDestroy 함수로 반드시 해제해야 하며 HeapDestroy 함수는 힙에 확정된 메모리를 확정 해제하고 예약도 취소함으로써 힙을 완전히 무효화 시키는 역할을 한다.

사용자 힙은 파괴하면 힙에 할당된 모든 블록들도 자동으로 파괴되므로 HeapFree 함수로 블록을 일일이 해제하지 않아도 상관없다.

===============================================================


< 예제 >

MyHeap = CreateHeap(0, 4096, 1048576);
ptr = (int*)HeapAlloc(MyHeap, 0, sizeof(int)*10);
for(i=0; i<10; i++){
	wsprintf(str, TEXT("%d"), str[i] = i*2);
	TextOut(hdc, 10, i*20, str, lstrlen(str));
}
HeapFree(MyHeap, 0, ptr);
HeapDestroy(MyHeap);
