< 파일 맵핑 오브젝트 생성 >

> HANDLE CreateFileMapping(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCTSTR lpName);

첫 번째 인수 hFile은 대상 파일의 핸들이다.
이 핸들은 CreateFile로 오픈한 핸들이거나 아니면 0xFFFFFFFF(=INVALID_HANDLE_VALUE)로 주어 페이징 파일의 일부 영역을 대신 사용할 수도 있다.

페이징 파일은 가상 메모리의 일부분이므로 하드 디스크의 파일이 아닌 가상 메모리에 파일 맵핑이 생성되며 이 방법은 두 프로세스의 메모리 공유에 사용된다.

두 번째 인수는 보안 정보를 가지는 구조체이되 대부분 NULL로 준다.

flProtect는 일종의 액세스 타입을 지정하는데 다음 중 한 값을 지정한다.

___________________________________________________________________________________________________
값				설명
===============================================================
PAGE_READONLY			읽기 전용의 파일 맵핑 오브젝트를 만든다.
				이렇게 만들어진 메모리 맵 파일에 쓰기를 해서는
				안되며 이 액세스 지정을 사용할 때 hFile은 반드시
				GENERIC_READ로 열려 있어야 한다.

PAGE_READWRITE			읽고 쓸 수 있는 파일 맵핑 오브젝트를 만든다.
				hFile은 GENERIC_READ | GENERIC_WRITE로
				열려 있어야 한다.

PAGE_WRITECOPY			읽고 쓸 수 있는 파일 맵핑 오브젝트를 만들되
				쓰기 즉시 복사(Write On Copy)기법을 사용한다.
				즉, 쓰기를 수행하는 시점에서 별도의 복사본이 생성된다
				95/98은 이 플래그를 지원하지 않는다.
===============================================================


이 외에 flProtect는 SEC_COMMIT, SEC_IMAGE, SEC_NOCACHE, SEC_RESERVE 등의 플래그들이 더 있는데 자세한 사항은 레퍼런스를 참고하기 바란다.


hFile이 디스크상의 파일인 경우 액세스 타입은 hFile의 액세스 타입과 호환되어야 한다.


네 번째 인수와 다섯 번째 인수는 생성될 파일 맵핑 오브젝트의 최대 크기를 지정하는 64비트의 정수이다.
Win32가 지원하는 메모리 맵 파일의 최대 크기는 64비트라는 엄청난 그야말로 무모할 정도로 큰 크기이다.

이 함수가 처음 만들어질 때만 해도 64비트 정수형이 없었기 때문에(지금은 있다) 32비트 정수 두 개를 사용하여 상위, 하위 32비트씩을 전달한다.

이 인수들이 모두 0이면 즉 파일 맵핑 오브젝트의 크기를 지정하지 않으면 hFile에서 지정한 파일의 크기가 그대로 사용된다.

파일 맵핑의 크기는 hFile이 -1일 경우, 즉 하드 디스크의 파일이 아닌 페이징 파일에 메모리 맵 파일을 생성할 때나 또는 대단히 큰 파일의 일부분만을 열고자 할 때 사용된다.




64비트라면 곧 2의 64승 크기를 말하며 이는 18뒤에 0을 18개를 붙인 수이다.

우리나라의 단위로 하면 180만조=1800경=0.18해가 된다.


컴퓨터 용어로는 16GG(기가 기가)바이트가 되며 한 단위로는 16E(엑사)바이트라고 읽는다.

32비트 크기로 할 경우 4G바이트 크기의 파일까지 처리할 수 있지만 아마도 DVD의 용량이 4.77G로 이미 32비트를 넘어섰기 때문에, 또한 그보다 더 큰 미디어가 이미 개발 완료된 상태이기 때문에 32비트로는 부족할지도 모른다고 생각했던 것 같다.




마지막 인수 lpname은 파일 맵핑 오브젝트의 이름이며 문자열 형태로 주므로 역슬래시 문자를 제외한 어떤 문자든지 사용할 수 있다.

필요하지 않을 경우 NULL로 주면 된다.

이 인수는 복수 개의 프로세스가 하나의 파일 맵핑 오브젝트를 공동으로 사용하고자 할 때 사용된다.
즉, 서로 다른 프로세스에서 같은 파일 맵핑 오브젝트를 얻기 위해서 그 이름을 약속할 때 사용한다.

이런 예는 앞에서도 사용자 정의 메시지나 클립보드 포맷을 등록할 때 본 적이 있다.



동기화 객체의 경우도 프로세스 간에 공유할 필요가 있는 것들은 구분 가능한 이름을 지정해야 한다.
이 예제는 파일 맵핑 오브젝트를 혼자서 사용하므로 이름을 줄 필요가 없다.


===============================================================

< 파일 맵핑 오브젝트를 주소 공간에 맵하는 함수>

> LPVOID MapViewOfFile(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, DWORD dwNumberOfBytesToMap);


함수 이름 그대로 파일의(OfFile) 뷰를(View) 주소 공간에 맵(Map)한다.

첫 번째 인수는 주소 공간에 맵하려는 파일 맵핑 오브젝트의 핸들이며 이는 CreateFileMapping함수로 생성된핸들이거나 아니면 OpenFileMapping에 의해 오픈한 핸들이다.

두 번째 인수는 액세스 지정이며 파일 맵핑 오브젝트를 만들 때도 지정했지만 뷰를 만들 때 각 뷰에 대해서도 액세스 지정을 다르게 할 수 있다.
단, 이 함수가 dwDesiredAccess 인수에서 지정한 액세스 지정은 CreateFileMapping 함수의 flProtect 인수와 적당히 호환되어야 한다.

예를 들어 여기서 FILE_MAP_WRITE 값을 주고 싶다면 맵핑 오브젝트를 만들 때도 쓰기가 가능하도록 했어야 한다는 상식적인 얘기다.


dwDesiredAccess는 다음 중 한 값을 가진다.
___________________________________________________________________________________________________
플래그			설명	
===============================================================
FILE_MAP_WRITE		읽고 쓸 수 있다.
FILE_MAP_READ		읽을 수 있다.
FILE_MAP_ALL_ACCESS	읽을 수도 있고 쓸 수도 있다.
FILE_MAP_COPY		읽고 쓸 수 있다. 쓰기 시도가 발생하면 데이터의 복사본을 만들고
			그 후에 쓴다.
===============================================================


세 번째 인수와 네 번째 인수는 맵핑을 시작할 오프셋 위치를 나타내는 64비트 정수를 지정한다.
이 값이 0이면 당연히 파일의 선두부터 맵핑되겠지만 0이 아니면 파일의 중간부터 맵핑할 수도 있다.

단, 이 오프셋은 반드시 시스템의 할당 단위(보통 64K)의 배수여야만 한다.

마지막 인수는 맵핑할 뷰의 크기를 지정한다. 이 값이 0이면 파일 전체가 맵되지만 일부만 맵하고자 하면 그 크기를 지정하면 된다. 

MapViewOfFile 함수는 인수가 지정하는대로 맵핑 오브젝트의 일부 또는 전체를 프로세스의 주소 공간에 맵한 후 그 시작 번지를 리턴한다.

이 포인터 값을 받아 마치 메모리를 읽고 쓰듯이 파일에 읽고 쓰기를 한다.

예제의 코드를 보면 다음과 같다.

hFile = CreateFile("NaRu.txt", GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
hFMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0,0, NULL);
ptrInFile = (TCHAR*)MapViewOfFile(hFMap, FILE_MAP_READ, 0,0,0);




하드 디스크의 Naru.txt 파일을 열어 그 핸들을 구하되 읽기만 할 것이므로 GENERIC_READ 액세스 타입으로 연다.

파일 맵핑에 사용할 파일은 다른 프로세스와 함께 공유할 수 없으므로 공유 플래그는 반드시 0으로 지정해야 한다.
메모리에 연결되어 있는 파일을 다른 프로세스가 변경하거나 지우도록 놔 둘 수는 없기 때문이다.

또한, 열려진 파일의 핸들은 파일 맵핑 오브젝트가 파괴되기 전까지 계속 열려 있어야 한다.

hFile 파일로부터 파일 맵핑 오브젝트를 만들어 hFMap 핸들에 대입하되 파일과 같은 액세스 타입으로 열었다.

파일 맵핑의 크기는 0으로 지정하여 hFile과 같은 크기를 가진다.

그리고 이 핸들을 사용하여 파일 전체를 주소 공간에 맵하고 그 포인터를 ptrInFIle 변수에 대입했다.
이후의 코드는 ptrInFile을 이용하여 파일의 내용을 메모리 읽듯이 읽어내는 것이다.





DrawText 함수를 사용해 ptrInFile 메모리 주소에 있는 문자열을 화면에 출력한다.

DrawText 함수는 메모리 상의 문자열을 읽어 화면으로 출력하는 함수이지 파일을 직접 읽어 출력하는 기능을 가지고 있지 않다.

그럼에도 이 경우는 아주 훌륭한 파일의 문자열을 출력하고 있다.



왜냐하면 메모리 맵 파일에 의해 디스크 상의 파일 이미지가 이 프로그램의 가상 주소 공간에 연결되어 있고 가상 주소 공간상의 문자열 포인터를 받았기 때문이다.

이렇게 연결된 파일을 다 사용하고 난 후에는 다음 함수로 뷰를 닫아야 한다.

뷰의 시작 번지를 인수로 넘기기만 하면 된다.



> BOOL UnmapViewOfFile(LPCVOID lpBaseAddress);



 그리고 파일 맵핑 오브젝트(hFMap)와 파일(hFile) 자체는 CloseHandle 함수로 제거한다.

이상이 메모리 맵 파일을 이용한 파일 읽기 시범이다.










참고로 우측 마우스 버튼을 누르면 Alpha.txt라는 텍스트 파일의 선두를 다른 문자열로 바꾸는데 절차나 사용하는 함수는 동일하되 액세스 지정만 바꾼 것이다.

메모리에 Alpha.txt 파일이 직접 맵 되었으므로 이 메모리의 내용을 바꾸는 것은 곧 파일의 내용을 바꾸는 것과 동일하다.

strncpy(wcsncpy) 등의 함수를 사용할 수도 있고 아니면 아예 ptrInFile 포인터와 첨자 연산자로 직접 문자열을 변경할 수도 있다.





시스템은 파일 뷰의 내용이 바뀔 때마다 즉시 디스크의 파일로 출력하지는 않는다.
변화된 부분에 대해 캐싱을 하다가 시스템이 한가해지면 파일로 쓰기를 한다.

캐시를 하지 않으면 효율이 형편없이 떨어지고 파일 맵핑을 사용하는 의미가 없어질 것이다.
만약, 즉시 캐시를 비워서 파일로 쓰게끔 하려면 FlushViewOfFile 함수를 호출하면 된다.